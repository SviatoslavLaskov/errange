using System.Diagnostics;
using System.Net;
using Errange.Exceptions;
using Errange.Extensions;
using Errange.ViewModels;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace Errange;

public abstract class ProblemPolicy
{
    internal abstract Type ExceptionType { get; }

    internal abstract ErrangeProblemDetails CreateProblemDetails(
        Exception baseException,
        HttpContext httpContext,
        IServiceProvider serviceProvider,
        bool shouldExceptionInfoBeIncluded);
}

public sealed class ProblemPolicy<TException> : ProblemPolicy where TException : Exception
{
    private readonly ICollection<Func<TException, HttpContext, IServiceProvider, IEnumerable<ProblemDataItem>>> _problemDataItemFactories = new List<Func<TException, HttpContext, IServiceProvider, IEnumerable<ProblemDataItem>>>();

    private Func<TException, string> ProblemCodeFactory { get; set; }

    private int HttpStatusCode { get; set; } = StatusCodes.Status500InternalServerError;

    private Func<TException, string>? TitleFactory { get; set; }

    private Func<TException, HttpContext, IServiceProvider, string?>? DetailFactory { get; set; }

    internal override Type ExceptionType { get; } = typeof(TException);

    internal ProblemPolicy() => ProblemCodeFactory = _ => ExceptionType.ToBase32Id();

    internal override ErrangeProblemDetails CreateProblemDetails(
        Exception baseException,
        HttpContext httpContext,
        IServiceProvider serviceProvider,
        bool shouldExceptionInfoBeIncluded)
    {
        var logger = serviceProvider.GetService<ILogger<ProblemPolicy<TException>>>();
        using IServiceScope serviceScope = serviceProvider.CreateScope();

        var exception = (TException)baseException;
        var errangeProblemDetails = new ErrangeProblemDetails
        {
            ProblemCode = ProblemCodeFactory(exception),
            Status = HttpStatusCode,
            Detail = InvokeFactory(
                () => DetailFactory?.Invoke(exception, httpContext, serviceScope.ServiceProvider),
                logger,
                $"An exception happened while generating '{nameof(ErrangeProblemDetails.Detail)}' property. Check '{nameof(WithDetail)}' method's parameters."),
            Title = TitleFactory?.Invoke(exception),
            Data = InvokeFactory<IDictionary<string, ProblemDataItem>>(
                    () => _problemDataItemFactories
                        .SelectMany(problemDataItemFactory => problemDataItemFactory(exception, httpContext, serviceScope.ServiceProvider))
                        .ToDictionary(dataItem => dataItem.Key, dataItem => dataItem),
                    logger,
                    $"An exception happened while generating one of '{nameof(ErrangeProblemDetails.Data)}' property's items.") ??
                new Dictionary<string, ProblemDataItem>(),
            TraceId = Activity.Current?.Id ?? httpContext.TraceIdentifier,
            ExceptionInfo = shouldExceptionInfoBeIncluded
                ? new ExceptionInfo
                {
                    Message = exception.Message,
                    StackTrace = exception.StackTrace?.Trim()
                }
                : null
        };

        return errangeProblemDetails;
    }

    /// <summary>
    ///     Sets <see cref="ErrangeProblemDetails.ProblemCode" /> (example - 'CUS001', where 'CUS' means
    ///     'CustomerApi' and 001 - the first error). By default is generated from exception's GUID (example - 'STB4YBKB'). In
    ///     2 different apps same exception will have same autogenerated problem code.
    /// </summary>
    /// <exception cref="ErrorPolicyConfigurationException"></exception>
    public ProblemPolicy<TException> WithCustomProblemCode(string code)
    {
        ProblemCodeFactory = _ => code;
        return this;
    }

    /// <summary>
    ///     Sets <see cref="ErrangeProblemDetails.ProblemCode" /> (example - 'CUS001', where 'CUS' means
    ///     'CustomerApi' and 001 - the first error). By default is generated from exception's GUID (example - 'STB4YBKB'). In
    ///     2 different apps same exception will have same autogenerated problem code.
    /// </summary>
    /// <exception cref="ErrorPolicyConfigurationException"></exception>
    public ProblemPolicy<TException> WithCustomProblemCode(Func<TException, string> codeFactory)
    {
        ProblemCodeFactory = codeFactory;
        return this;
    }

    /// <summary>
    ///     Sets HTTP response status code and <see cref="ErrangeProblemDetails.Status" /> (to be able to identify status
    ///     code at raw text body or after reverse proxy status code change). Default is
    ///     <see cref="HttpStatusCode.InternalServerError" />.
    /// </summary>
    public ProblemPolicy<TException> WithHttpStatusCode(HttpStatusCode httpStatusCode) => WithHttpStatusCode((int)httpStatusCode);

    /// <summary>
    ///     Sets HTTP response status code and <see cref="ErrangeProblemDetails.Status" /> (to be able to identify status
    ///     code at raw text body or after reverse proxy status code change). Default is
    ///     <see cref="StatusCodes.Status500InternalServerError" />.
    /// </summary>
    /// <param name="httpStatusCode">
    ///     Integer status codes are specified at <see cref="StatusCodes" />. Custom status codes are allowed.
    /// </param>
    public ProblemPolicy<TException> WithHttpStatusCode(int httpStatusCode)
    {
        HttpStatusCode = httpStatusCode;
        return this;
    }

    /// <summary>
    ///     Sets <see cref="ErrangeProblemDetails.Title" />. A short, human-readable summary of problem (example - 'Customer
    ///     with this nickname is already registered.').
    /// </summary>
    public ProblemPolicy<TException> WithTitle(string title)
    {
        ProblemCodeFactory = _ => title;
        return this;
    }

    /// <summary>
    ///     Sets <see cref="ErrangeProblemDetails.Title" />. A short, human-readable summary of problem (example - 'Customer
    ///     with this nickname is already registered.').
    /// </summary>
    public ProblemPolicy<TException> WithTitle(Func<TException, string> problemCodeFactory)
    {
        ProblemCodeFactory = problemCodeFactory;
        return this;
    }

    /// <summary>
    ///     Sets <see cref="ErrangeProblemDetails.Detail" />. A human-readable explanation specific to this occurrence of
    ///     the problem (example - 'Nickname 'superuser123' is already used.').
    /// </summary>
    public ProblemPolicy<TException> WithDetail(string detail)
    {
        DetailFactory = (_, _, _) => detail;
        return this;
    }

    /// <summary>
    ///     Sets <see cref="ErrangeProblemDetails.Detail" />. A human-readable explanation specific to this occurrence of
    ///     the problem (example - 'Nickname 'superuser123' is already used.').
    /// </summary>
    public ProblemPolicy<TException> WithDetail(Func<TException, HttpContext, IServiceProvider, string?> detailFactory)
    {
        DetailFactory = detailFactory;
        return this;
    }

    /// <summary>
    ///     Is used to populate human-readable message template at UI. For example, user tries to register with already used
    ///     nickname. To populate human-readable message this nickname may be included into data.
    /// </summary>
    public ProblemDataItemBuilder<TException> WithDataItem(Func<TException, HttpContext, IServiceProvider, string> keyFactory)
    {
        var problemDataItemBuilder = new ProblemDataItemBuilder<TException>(keyFactory, this);
        _problemDataItemFactories.Add((exception, httpContext, serviceProvider) => problemDataItemBuilder.ShouldBeBuilt(exception, httpContext, serviceProvider)
            ? new[] { problemDataItemBuilder.Build(exception, httpContext, serviceProvider) }
            : Enumerable.Empty<ProblemDataItem>());

        return problemDataItemBuilder;
    }

    /// <summary>
    ///     Is used to populate human-readable message template at UI. For example, user tries to register with already used
    ///     nickname. To populate human-readable message this nickname may be included into data.
    /// </summary>
    public ProblemDataItemBuilder<TException> WithDataItem(Func<TException, string> keyFactory)
    {
        if (keyFactory == null) throw new ArgumentNullException(nameof(keyFactory));
        return WithDataItem((exception, _, _) => keyFactory(exception));
    }

    /// <summary>
    ///     Is used to populate human-readable message template at UI. For example, user tries to register with already used
    ///     nickname. To populate human-readable message this nickname may be included into data.
    /// </summary>
    public ProblemDataItemBuilder<TException> WithDataItem(Func<HttpContext, string> keyFactory)
    {
        if (keyFactory == null) throw new ArgumentNullException(nameof(keyFactory));
        return WithDataItem((_, httpContext, _) => keyFactory(httpContext));
    }

    /// <summary>
    ///     Is used to populate human-readable message template at UI. For example, user tries to register with already used
    ///     nickname. To populate human-readable message this nickname may be included into data.
    /// </summary>
    public ProblemDataItemBuilder<TException> WithDataItem<TService>(Func<TService, string> keyFactory) where TService : notnull
    {
        if (keyFactory == null) throw new ArgumentNullException(nameof(keyFactory));
        return WithDataItem((_, _, serviceProvider) => keyFactory(serviceProvider.GetRequiredService<TService>()));
    }

    /// <summary>
    ///     Is used to populate human-readable message template at UI. For example, user tries to register with already used
    ///     nickname. To populate human-readable message this nickname may be included into data.
    /// </summary>
    public ProblemDataItemBuilder<TException> WithDataItem(string key)
    {
        if (key == null) throw new ArgumentNullException(nameof(key));
        return WithDataItem((_, _, _) => key);
    }

    /// <summary>
    ///     Is used to populate human-readable message template at UI. This method makes possible to include list of data
    ///     items, if data item keys are not known at build time.
    /// </summary>
    public ProblemPolicy<TException> WithDataItems<TSourceItem, TDataItemValue>(
        Func<TException, HttpContext, IServiceProvider, IEnumerable<TSourceItem>> sourceItemsSelector,
        Func<TSourceItem, TException, HttpContext, IServiceProvider, string> keyFactory,
        Func<TSourceItem, TException, HttpContext, IServiceProvider, TDataItemValue?> valueFactory,
        Func<TSourceItem, TException, HttpContext, IServiceProvider, IEnumerable<string>>? messagesFactory)
    {
        if (sourceItemsSelector == null) throw new ArgumentNullException(nameof(sourceItemsSelector));
        if (keyFactory == null) throw new ArgumentNullException(nameof(keyFactory));
        if (valueFactory == null) throw new ArgumentNullException(nameof(valueFactory));

        _problemDataItemFactories.Add((exception, httpContext, serviceProvider) =>
        {
            TSourceItem[] sourceItems = InvokeFactory(

                // ReSharper disable once ConditionalAccessQualifierIsNonNullableAccordingToAPIContract
                () => sourceItemsSelector(exception, httpContext, serviceProvider)?.ToArray(),
                serviceProvider.GetService<ILogger<ProblemPolicy<TException>>>(),
                "An exception happened while generating source items.") ?? Array.Empty<TSourceItem>();

            return sourceItems.Select(sourceItem => new ProblemDataItemBuilder<TException>((exception, httpContext, serviceProvider) => keyFactory(sourceItem, exception, httpContext, serviceProvider), this)
                .WithValue((exception, httpContext, serviceProvider) => valueFactory(sourceItem, exception, httpContext, serviceProvider))
                .WithMessages(messagesFactory is null
                    ? Array.Empty<string>()
                    : messagesFactory(sourceItem, exception, httpContext, serviceProvider).ToArray())
                .Build(exception, httpContext, serviceProvider)); // ShouldBeBuilt is not used as When is not used
        });

        return this;
    }

    private static T? InvokeFactory<T>(Func<T?> factory, ILogger<ProblemPolicy<TException>>? logger, string errorMessage) where T : class
    {
        try
        {
            return factory();
        }
        catch (Exception factoryInvocationException)
        {
            logger?.LogError(factoryInvocationException, errorMessage);
        }

        return null;
    }
}